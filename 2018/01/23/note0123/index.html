<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="XY"><meta name="description" content="不会跳hiphop的全站攻城狮不是一个好的个人游戏开发程序媛"><link rel="alternative" href="/atom.xml" title="StringXy" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>《大型网站系统与java中间件实践》笔记三 - StringXy</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">StringXy</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-01-23T02:24:42.000Z">January 23, 2018</time><h1 class="post__title"><a href="/2018/01/23/note0123/">《大型网站系统与java中间件实践》笔记三</a></h1><div class="post__main echo"><h2 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h2><h4 id="常见的异步远程通信方式"><a href="#常见的异步远程通信方式" class="headerlink" title="常见的异步远程通信方式"></a>常见的异步远程通信方式</h4><ul>
<li>Oneway：一个单向（不保证可靠送达）的通知</li>
<li>Callback：一种被动的回调方式，执行不在原线程中</li>
<li>Future：一种能够主动控制超时，获取结果的方式，在原请求线程中执行</li>
<li>可靠异步：保证异步请求在远程被执行</li>
</ul>
<h4 id="ESB（企业服务总线）与服务框架的差异"><a href="#ESB（企业服务总线）与服务框架的差异" class="headerlink" title="ESB（企业服务总线）与服务框架的差异"></a>ESB（企业服务总线）与服务框架的差异</h4><ul>
<li>服务框架是一个点对点的模型，ESB是一个总线式的模型</li>
<li>服务框架面向同构的系统，不重点考虑整合的需求，ESB会更多地考虑不同厂商所提供服务的整合。 </li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="分布式事务模型与规范"><a href="#分布式事务模型与规范" class="headerlink" title="分布式事务模型与规范"></a>分布式事务模型与规范</h3><h4 id="分布式事务处理模型–X-Open-DTP模型"><a href="#分布式事务处理模型–X-Open-DTP模型" class="headerlink" title="分布式事务处理模型–X/Open DTP模型"></a>分布式事务处理模型–X/Open DTP模型</h4><ul>
<li>DTP（X/Open Distributed Transaction Processiing Reference Model）模型中定义了三个组件：Application Program,Resource Manager,Transaction Manager.</li>
<li>两阶段提交：在分布式系统中，在提交之前增加了准备的阶段。在进行垂直拆分或水平拆分后，在必要的情况才建议使用两阶段提交，否则会增大开销。<h3 id="大型网站一致性的基础理论"><a href="#大型网站一致性的基础理论" class="headerlink" title="大型网站一致性的基础理论"></a>大型网站一致性的基础理论</h3><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4></li>
<li>Consistency（一致性）：all nodes see the same data at the same time</li>
<li>Availability(可用性)：a guarantee that every request receives a response about whether it was successful or failed .保证无论成功或失败，每个请求都能收到反馈。</li>
<li>Partition-Tolerance（分区容忍性）:the system continues to operate despite arbitrary message loss or failure of part of the system.系统有部分问题或消息丢失都能继续运行。<h4 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h4></li>
<li>Basically Available:基本可用，允许分区失败。</li>
<li>Soft state：软状态，接受一段时间的状态不同步</li>
<li>Eventually consistent：最终一致性。<h4 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h4></li>
<li>作用：Paxos算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。用于解决分布式系统中一致性问题。</li>
<li>角色：Proposer(提议发起者)；Acceptor(提议接受者)；Learner(提议学习者)；</li>
<li>Proposal(提案)：由proposer提出，被aceeptor批准或否决，包含｛编号，提案值｝；</li>
<li>Accept(批准): 表示提案被acceptor批准；</li>
<li>Choose(选择): 表示提案“被选择”，也就是被多数acceptor批准</li>
<li>Value（提案值）: 提案的值，议案的组成之一</li>
<li>Proposal Number（提案编号）：提案编号不能冲突，提案的组成之一</li>
</ul>
<p>参考链接：<a href="https://www.jianshu.com/p/5e9aeb46540f" target="_blank" rel="noopener">Paxos协议学习笔记</a></p>
<h4 id="数据一致性的算法"><a href="#数据一致性的算法" class="headerlink" title="数据一致性的算法"></a>数据一致性的算法</h4><p>Quorum是用来权衡分布式系统中数据一致性和可用性的。<br>N：数据复制节点数量<br>R：成功读操作的最小节点数<br>W：成功写操作的最小节点数<br>如果W+R&gt;N,可以保证强一致性<br>如果W+R&lt;=N,保证最终一致性</p>
<p>Vector Clock对同一份数据的每一次修改都加上“&lt;修改者，版本号&gt;”，通过这样的信息来帮助解决一些冲突。</p>
<h2 id="数据访问层的设计与实现"><a href="#数据访问层的设计与实现" class="headerlink" title="数据访问层的设计与实现"></a>数据访问层的设计与实现</h2><h3 id="数据层的流程设计"><a href="#数据层的流程设计" class="headerlink" title="数据层的流程设计"></a>数据层的流程设计</h3><p><img src="/2018/01/23/note0123/1.png" alt="数据层的整体流程"></p>
<h4 id="SQL解析阶段"><a href="#SQL解析阶段" class="headerlink" title="SQL解析阶段"></a>SQL解析阶段</h4><ul>
<li>具体解析时可用antlr、javacc等</li>
<li>为了安全，解析的缓冲需要加上数据上线</li>
</ul>
<h4 id="规则处理阶段-（帮助确定一组数据源）"><a href="#规则处理阶段-（帮助确定一组数据源）" class="headerlink" title="规则处理阶段 （帮助确定一组数据源）"></a>规则处理阶段 （帮助确定一组数据源）</h4><ul>
<li>一致性哈希增加/减少节点时负载不均衡的问题，可以通过一个物理节点对应多个虚拟节点，虚拟节点均匀分布来解决。</li>
<li>映射表可用于对热点数据的特殊处理，或者在一些场景下对不完全符合规律的规则进行补充</li>
<li>自定义计算方式可以通过比较复杂的函数计算来解决数据访问的规则问题</li>
</ul>
<h4 id="SQL改写阶段"><a href="#SQL改写阶段" class="headerlink" title="SQL改写阶段"></a>SQL改写阶段</h4><ul>
<li>不同库中的表名最好是唯一</li>
</ul>
<h4 id="选择数据源阶段"><a href="#选择数据源阶段" class="headerlink" title="选择数据源阶段"></a>选择数据源阶段</h4><ul>
<li>数据库分组一般是一写多读（也有多写多读），根据当前执行的SQL特点（读/写），是否在事务中，各个库的权重规则，计算得到这次SQL要访问的数据库。</li>
</ul>
<h4 id="执行SQL和结果处理阶段"><a href="#执行SQL和结果处理阶段" class="headerlink" title="执行SQL和结果处理阶段"></a>执行SQL和结果处理阶段</h4><ul>
<li>SQL执行时需要从异常中明确判断出数据库不可用的情况</li>
</ul>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li>JMS Queue 模型，也称为Peer To Peer(PTP)</li>
<li>JMS Topic模型，也被称为Pub/Sub方式<h3 id="JMS的消息确认方式与消息重复的关系"><a href="#JMS的消息确认方式与消息重复的关系" class="headerlink" title="JMS的消息确认方式与消息重复的关系"></a>JMS的消息确认方式与消息重复的关系</h3></li>
<li>AUTO_ACKNOWLEDGE：自动确认，确认是可能还没来得及处理，所以这种方式对于消息投递处理来说不可靠。</li>
<li>CLIENT_ACKNOWLEDGE：客户端确认。客户端主动调用Message接口的acknowledge()方法确认，这种方式控制权完全交给了客户端</li>
<li>DUPS_OK_ACKNOWLEDGE：中消息接收方的消息处理函数执行结束后确认，保证了消息一定是在处理结束后确认，也不需要客户端主动调用方法。</li>
</ul>
<h3 id="Push和Pull方式的对比"><a href="#Push和Pull方式的对比" class="headerlink" title="Push和Pull方式的对比"></a>Push和Pull方式的对比</h3><p><img src="/2018/01/23/note0123/2.png" alt="Push和Pull方式的对比"></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/读书笔记/">读书笔记</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 XY</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>