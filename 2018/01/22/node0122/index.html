<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="XY"><meta name="description" content="不会跳hiphop的全站攻城狮不是一个好的个人游戏开发程序媛"><link rel="alternative" href="/atom.xml" title="StringXy" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>《大型网站系统与java中间件实践》笔记二 - StringXy</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">StringXy</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-01-22T02:36:40.000Z">January 22, 2018</time><h1 class="post__title"><a href="/2018/01/22/node0122/">《大型网站系统与java中间件实践》笔记二</a></h1><div class="post__main echo"><h2 id="java并发编程的类、接口和方法"><a href="#java并发编程的类、接口和方法" class="headerlink" title="java并发编程的类、接口和方法"></a>java并发编程的类、接口和方法</h2><h4 id="线程池（ThreadPoolExecutor）"><a href="#线程池（ThreadPoolExecutor）" class="headerlink" title="线程池（ThreadPoolExecutor）"></a>线程池（ThreadPoolExecutor）</h4><ol>
<li>与每次都创建线程相比，线程池在线程结束后进行回收操作，而不真正销毁线程，从而降低创建线程的开销。</li>
<li>ScheduledThreadPoolExecutor(定时线程池)</li>
<li>Executors.newCachedThreadPool()该方法返回的线程池没有线程上线，可能导致过多内存占用，不建议使用。</li>
</ol>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ol>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象</li>
<li>如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁</li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li>
</ol>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li>ReentrantLock是java.util.concurrent.locks中的一个类，从jdk5开始加入。</li>
<li>提供了tryLock方法，若锁被其他线程持有，返回false，若没有，当前线程会持有锁，返回true</li>
<li>构造ReentrantLock对象可接受一个boolean参数，描述是否使用公平锁。</li>
<li>提供ReentrantReadWriteLock，用于读多写少并且读不需要互斥的场景，比全部互斥性能高。<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul>
<li>保证了同一个变量在多线程中的可见性。</li>
<li>volatile不能控制并发，synchronized保证了代码块的串行执行。</li>
</ul>
</li>
</ul>
<h4 id="Atomics"><a href="#Atomics" class="headerlink" title="Atomics"></a>Atomics</h4><ul>
<li>在JDK5中增加了java.util.concurrent.atomic包，其中是一些以Atomic开头的类，提供了相关的原子操作</li>
<li>性能提升的原因是内部通过JNI的方式使用了硬件支持的CAS指令<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4></li>
<li>CountDownLatch是java.util.concurrent包中的一个类。提供当多个线程达到预期（调用countDown方法）后触发事件（等待的线程调用await方法）。</li>
</ul>
<h4 id="CyclicBarrier（循环屏障）"><a href="#CyclicBarrier（循环屏障）" class="headerlink" title="CyclicBarrier（循环屏障）"></a>CyclicBarrier（循环屏障）</h4><ul>
<li>多个线程在这个屏障前等待（调用await方法），都到达后一起执行后面的动作。</li>
<li>CountDownLatch不能循环使用，CyclicBarrier可以循环使用</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><ul>
<li>用于管理信号量（控制并发），构造的时候传入可供管理的信号量数值。</li>
<li>通过acquire获取信号许可，通过release归还信号许可，acquire，release的参数含义：获取/返还的信号量个数。</li>
</ul>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><ul>
<li>用于在两个线程之间进行数据交换。</li>
</ul>
<h4 id="Future-FutureTask"><a href="#Future-FutureTask" class="headerlink" title="Future/FutureTask"></a>Future/FutureTask</h4><ul>
<li>Future是一个接口/FutureTask是一个具体实现类</li>
</ul>
<h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><ul>
<li>CopyOnWrite适用于读多写少的场景，在写时重建了一次容器。</li>
<li>Concurrent尽量保证读不加锁，修改时不影响读，并发性能比读写锁高</li>
</ul>
<h2 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h2><h4 id="服务调用端的设计与实现"><a href="#服务调用端的设计与实现" class="headerlink" title="服务调用端的设计与实现"></a>服务调用端的设计与实现</h4><p><img src="/2018/01/22/node0122/1.png" alt=""></p>
<h4 id="远程通信"><a href="#远程通信" class="headerlink" title="远程通信"></a>远程通信</h4><ul>
<li>调用远程服务后，服务注册查找中心提供服务者列表，并把地址缓存在调用者本地</li>
<li>服务提供者列表有变化时服务注册查找中心发出通知，告诉调用者。</li>
<li>为当次的调用进行集群的负载均衡（随机/轮询/权重…），除了硬件负载均衡设备，常用的有LVS，HAProxy等替代硬件等策略</li>
</ul>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/读书笔记/">读书笔记</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 XY</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>